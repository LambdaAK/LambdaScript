\documentclass[titlepage]{article}
\usepackage{syntax}
\usepackage{amsfonts}
\usepackage[dvipsnames]{xcolor}




\title{LambdaScript Syntax and Semantics}
\author{Alex Kozik}
\begin{document}

\newcommand{\desc}[1]{\textit{\textcolor{Aquamarine}{#1}}}



\maketitle
\tableofcontents
\newpage

\section{Syntax}

\subsection{Metavariables}

Below is a list of meta-variables for different fundamental langauge constructs

\begin{minipage}[t]{0.4\textwidth}



$x \in  Var$

$b \in \{true, false\}$

$n \in \mathbb{N}$

$s \in \Sigma ^ *$

$\oplus$ $\in$ $\{+, -, *, /, \%, <, >, <=, >=, ==, !=\}$


\end{minipage}
\begin{minipage}[t]{0.6\textwidth}
Variable indentifier

Boolean

Natural number

String

Binary operator

Unary operator

\end{minipage}
\subsection{Expressions}

\begin{minipage}[t]{0.6\textwidth}

  \begin{grammar}


    <e> ::= n 
    \alt b 
    \alt s 
    \alt () 
    \alt x
    \alt $e_1 \oplus e_2$
    \alt ($e_1$, $e_2$, ..., $e_n$)
    \alt [\space]
    \alt $e_1$ :: $e_2$
    \alt \textbf{fn} $p$ $\rightarrow$ $e$
    \alt \textbf{bind} p $\leftarrow$ $e_1$ \textbf{in} $e_2$
    \alt \textbf{bind} $p$ \space $p_1$ ... $p_n$ $\leftarrow$ $e_1$ \textbf{in} $e_2$
    \alt \textbf{bind rec} $f$ $\leftarrow$ \textbf{fn} p $\rightarrow$ $e_1$ \textbf{in} $e_2$
    \alt \textbf{bind rec} $f$ \space $p_1$ ... $p_n$ $\leftarrow$ $e_1$ in $e_2$
    \alt $e_1$ \space $e_2$
    \alt \textbf{if} $e_1$ \textbf{then} $e_2$ \textbf{else} $e_3$
    \alt \textbf{switch} $e_0$ $=>$ | $p_1 \rightarrow e_1$ ... | $p_n \rightarrow e_n$ \textbf{end}
    
    
    \end{grammar}
\end{minipage}
\hfill
\begin{minipage}[t]{0.3\textwidth}

  Integer

  Boolean

  String

  Nothing

  Identifier

  Binary Operation

  Vector

  Nil (empty list)

  Cons (nonempty list)

  Function

  Bind expression

  Bind expression

  Recursive function bind

  Recursive function bind

  Function application

  Ternary expressions

  Switch expression
\end{minipage}


\subsection{Patterns}
\begin{minipage}[t]{0.5\textwidth}
\begin{grammar}



<p> ::= _
\alt x
\alt ()
\alt b
\alt n
\alt s
\alt ($p_1$, $p_2$, ..., $p_n$)
\alt [\space]
\alt $p_1$ :: $p_2$

\end{grammar}
\newpage



 
\end{minipage}
\begin{minipage}[t]{0.3\textwidth}
Wildcard pattern*

Identifier pattern**

Nothing pattern

Boolean pattern

Integer pattern

String pattern

Vector pattern

Nil pattern

Cons pattern***

\end{minipage}

* The wildcard pattern matches any value

** The identifier pattern matches any value and produces a binding to it

*** The cons pattern matches a non empty list, but only $p_1$ matches the head of the list and $p_2$ matches the remainder of the list
\subsection{Values}

\begin{minipage}[t]{0.5\textwidth}


\begin{grammar}

  <v> ::= n
  \alt s
  \alt b
  \alt ()
  \alt [\space ]
  \alt $v_1$ :: $v_2$
  \alt ($\Delta$, p, e)
  
  
  \end{grammar} 
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
  Integer value

  String value

  Boolean value

  Nothing value

  Nil value

  Cons value

  Function Closure

\end{minipage}

\subsection{Types}
\begin{minipage}[t]{0.5\textwidth}
\begin{grammar}
<t> ::= int
\alt bool
\alt str
\alt ng
\alt $t_i$
\alt $t_1 \rightarrow t_2$
\alt [\space $t$\space ]
\alt ($t_1$, $t_2$, ..., $t_n$)
\alt ( $t$ )
\end{grammar}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
  Integer type

  Boolean type

  String type

  Nothing type

  Type variable

  Function type*

  List type

  Vector type

  Parenthesized type*
  \end{minipage}%

\vspace{0.25in}
* The function type operator $\rightarrow$ associates to the right

For example, the type $t_1 \rightarrow t_2 \rightarrow t_3$ is parsed as $t_1 \rightarrow (t_2 \rightarrow t_3)$

Parentheses are the highest precedence operator in the type grammar, and they can be used to counter act this.

For example

\begin{center}

fn f $\rightarrow$ fn x $\rightarrow$ f x : $(t_1 \rightarrow t_2) \rightarrow t_1 \rightarrow t_2$

\end{center}



\newpage
\section{Dynamic Semantics}

In order to discuss the dynamic semantics of the programming language, we first need to
define a few things.


\subsection{Dynamic Environment}
LambdaScript uses an environment model to make substitutions in function bodies. The environment is an object defined as follows
$$\Delta \in Var  \rightarrow Value$$


It is essentally a function from a set of variable identifiers to a set of values. Note that it is a partial function because its domain will be a subset of $Var$
\begin{itemize}
\item $\Delta (x)$ represents the value $x$ maps to in environment $\Delta$
\item $\{\}$ is the empty environment
\item $\Delta [x \rightarrow v]$ represents the environment where $\Delta (y) = v$ if $y = x$, and $\Delta (y)$ otherwise
\item $D(\Delta)$ is the domain of $\Delta$
\end{itemize}

\subsection{Evaluation Relation}

The evaluation relation is what describes how an expression is evaluated to a value under a certain environment

Define it as follows

$$(\Delta, e) \Rightarrow v$$

It means the following: Under environment $\Delta$, expression $e$ evaluates to value $v$

\subsection{The Dynamic Semantics}

\subsubsection{Value}

$$(\Delta, v) \Rightarrow v$$

A value always evaluates to itself

\subsubsection{Variable Identifiers}
$$(\Delta, x) \Rightarrow \Delta (x)$$

To evaluate an identifier $x$, it is simply looked up in the environment $\Delta$

\subsubsection{Vector}

$$(\Delta, (e_1, e_2, ..., e_n)) \Rightarrow (v_1, v_2, ..., v_n)$$

\noindent\makebox[\linewidth]{\rule{2.1in}{0.4pt}}
$$(\Delta, e_1) \Rightarrow v_1$$
$$(\Delta, e_2) \Rightarrow v_2$$
$$\dots$$
$$(\Delta, e_n) \Rightarrow v_n$$


To evaluate a vector, evaluate each sub expression, then construct a new vector with the values

\subsubsection{Cons}

$$(\Delta, e_1 :: e_2) \Rightarrow v_1 :: v_2$$
\noindent\makebox[\linewidth]{\rule{1.4in}{0.4pt}}
$$(\Delta, e_1) \Rightarrow v_1$$
$$(\Delta, e_2) \Rightarrow v_2$$

To evaluate a cons expression, evaluate the two operands, then return the first argument prepended to the second



\section{Static Semantics}

\end{document}