\documentclass[titlepage]{article}
\usepackage{syntax}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[dvipsnames]{xcolor}
\usepackage[left=2cm, right=2cm]{geometry}



\title{LambdaScript Syntax and Semantics}
\author{Alex Kozik}
\begin{document}
\large
\newcommand{\desc}[1]{\textit{\textcolor{Aquamarine}{#1}}}



\maketitle
\tableofcontents
\newpage

\section{Syntax}

\subsection{Metavariables}

Below is a list of meta-variables for different fundamental langauge constructs

\begin{minipage}[t]{0.4\textwidth}



$x \in  Var$

$b \in \{true, false\}$

$n \in \mathbb{N}$

$s \in \Sigma ^ *$

$\oplus$ $\in$ $\{+, -, *, /, \%, <, >, <=, >=, ==, !=\}$


\end{minipage}
\begin{minipage}[t]{0.6\textwidth}
Variable indentifier

Boolean

Natural number

String

Binary operator

Unary operator

\end{minipage}
\subsection{Expressions}

\begin{minipage}[t]{0.6\textwidth}

  \begin{grammar}


    <e> ::= n 
    \alt b 
    \alt s 
    \alt () 
    \alt x
    \alt $e_1 \oplus e_2$
    \alt ($e_1$, $e_2$, ..., $e_n$)
    \alt [\space]
    \alt $e_1$ :: $e_2$
    \alt \textbf{fn} $p$ $\rightarrow$ $e$
    \alt \textbf{bind} p $\leftarrow$ $e_1$ \textbf{in} $e_2$
    \alt \textbf{bind} $p$ \space $p_1$ ... $p_n$ $\leftarrow$ $e_1$ \textbf{in} $e_2$
    \alt \textbf{bind rec} $f$ $\leftarrow$ \textbf{fn} p $\rightarrow$ $e_1$ \textbf{in} $e_2$
    \alt \textbf{bind rec} $f$ \space $p_1$ ... $p_n$ $\leftarrow$ $e_1$ in $e_2$
    \alt $e_1$ \space $e_2$
    \alt \textbf{if} $e_1$ \textbf{then} $e_2$ \textbf{else} $e_3$
    \alt \textbf{switch} $e_0$ $=>$ | $p_1 \rightarrow e_1$ ... | $p_n \rightarrow e_n$ \textbf{end}
    
    
    \end{grammar}
\end{minipage}
\hfill
\begin{minipage}[t]{0.3\textwidth}

  Integer

  Boolean

  String

  Nothing

  Identifier

  Binary Operation

  Vector

  Nil (empty list)

  Cons (nonempty list)

  Function

  Bind expression

  Bind expression

  Recursive function

  Recursive function

  Function application

  Ternary expressions

  Switch expression
\end{minipage}


\subsection{Patterns}
\begin{minipage}[t]{0.5\textwidth}
\begin{grammar}



<p> ::= _
\alt x
\alt ()
\alt b
\alt n
\alt s
\alt ($p_1$, $p_2$, ..., $p_n$)
\alt [\space]
\alt $p_1$ :: $p_2$

\end{grammar}
\newpage



 
\end{minipage}
\begin{minipage}[t]{0.3\textwidth}
Wildcard pattern*

Identifier pattern**

Nothing pattern

Boolean pattern

Integer pattern

String pattern

Vector pattern

Nil pattern

Cons pattern***

\end{minipage}

* The wildcard pattern matches any value

** The identifier pattern matches any value and produces a binding to it

*** The cons pattern matches a non empty list, but only $p_1$ matches the head of the list and $p_2$ matches the remainder of the list
\subsection{Values}

\begin{minipage}[t]{0.5\textwidth}


\begin{grammar}

  <v> ::= n
  \alt s
  \alt b
  \alt ()
  \alt [\space ]
  \alt $v_1$ :: $v_2$
  \alt ($\Delta$, p, e)
  
  
  \end{grammar} 
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
  Integer value

  String value

  Boolean value

  Nothing value

  Nil value

  Cons value

  Function Closure

\end{minipage}

\subsection{Types}
\begin{minipage}[t]{0.5\textwidth}
\begin{grammar}
<t> ::= int
\alt bool
\alt str
\alt ng
\alt $t_i$
\alt $t_1 \rightarrow t_2$
\alt [\space $t$\space ]
\alt ($t_1$, $t_2$, ..., $t_n$)
\alt ( $t$ )
\end{grammar}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
  Integer type

  Boolean type

  String type

  Nothing type

  Type variable

  Function type*

  List type

  Vector type

  Parenthesized type*
  \end{minipage}%

\vspace{0.25in}
* The function type operator $\rightarrow$ associates to the right

For example, the type $t_1 \rightarrow t_2 \rightarrow t_3$ is parsed as $t_1 \rightarrow (t_2 \rightarrow t_3)$

Parentheses are the highest precedence operator in the type grammar, and they can be used to counter the right associativity of the arrrow operator.

For example

\begin{center}

fn f $\rightarrow$ fn x $\rightarrow$ f x : $(t_1 \rightarrow t_2) \rightarrow t_1 \rightarrow t_2$

\end{center}



\newpage
\section{Dynamic Semantics}

In order to discuss the dynamic semantics of the programming language, we first need to
define a few things.


\subsection{Dynamic Environment}
LambdaScript uses an environment model to make substitutions in function bodies. The environment is an object defined as follows
$$\Delta \in Var  \rightarrow Value$$


It is essentally a function from a set of variable identifiers to a set of values. Note that it is a partial function because its domain will be a subset of $Var$
\begin{itemize}
\item $\Delta (x)$ represents the value $x$ maps to in environment $\Delta$
\item $\{\}$ is the empty environment
\item $\Delta [x \rightarrow v]$ represents the environment where $\Delta (y) = v$ if $y = x$, and $\Delta (y)$ otherwise
\item $D(\Delta)$ is the domain of $\Delta$
\item $\Delta_1 \circ \Delta_2$ represents the environment $\Delta$ where $\forall y \in D(\Delta_2)$, $\Delta(y) = \Delta_2(y)$, $\forall y \in D(\Delta_1) - D(\Delta_2)$, $\Delta(y) = \Delta_1(y)$. Otherwise, $\Delta(y)$ is not defined.
\end{itemize}

\subsection{Evaluation Relation}

The evaluation relation is what describes how an expression is evaluated to a value under a certain environment

Define it as follows

$$(\Delta, e) \Rightarrow v$$

It means the following: Under environment $\Delta$, expression $e$ evaluates to value $v$

\subsection{Pattern Matching Relation}

In order to model a value matching some pattern, and producing some bindings, we will use the following relation

$$v \in p \rightarrow \Delta$$

This can be read as "value $v$ matches pattern $p$ and produces bindings $\Delta$"

We will also use the following relation

$$v \notin p$$

This can be read as "value $v$ does not patch pattern $p$"

Below are the semantics for each pattern

\vspace{1in}

\begin{center}

Wildcard

\end{center}


$$v \in \_ \rightarrow \{\}$$


\begin{center}

Variable Identifier
  
\end{center}
  
  
$$v \in x \rightarrow \{\}[x \rightarrow v]$$


\begin{center}

Nothing

\end{center}


$$() \in () \rightarrow \{\}$$


\begin{center}

Boolean

\end{center}


$$b \in b \rightarrow \{\}$$

\begin{center}

Integer

\end{center}


$$i \in i \rightarrow \{\}$$


\begin{center}

String

\end{center}


$$s \in s \rightarrow \{\}$$

\begin{center}

Nil / Empty List

\end{center}


$$[] \in [] \rightarrow \{\}$$



\begin{center}

Vector

\end{center}


$$(v_1, v_2, ..., v_n) \in (p_1, p_2, ..., p_n) \rightarrow \Delta_1 \circ \Delta _2 \circ ... \circ ... \Delta_n$$
\noindent\makebox[\linewidth]{\rule{3.65in}{0.4pt}}
$$v_1 \in p_1 \rightarrow \Delta_1$$
$$v_2 \in p_2 \rightarrow \Delta_2$$
$$\dots$$
$$v_n \in p_n \rightarrow \Delta_n$$


\begin{center}

Cons

\end{center}


$$v_1 :: v_2 \in p_1 :: p_2 \rightarrow \Delta_1 \circ \Delta_2$$
\noindent\makebox[\linewidth]{\rule{2in}{0.4pt}}
$$v_1 \in p_1 \rightarrow \Delta_1$$
$$v_2 \in p_2 \rightarrow \Delta_2$$

\subsection{Basic Dynamic Semantics}

\subsubsection{Value}

$$(\Delta, v) \Rightarrow v$$

A value always evaluates to itself

\subsubsection{Variable Identifiers}
$$(\Delta, x) \Rightarrow \Delta (x)$$

To evaluate an identifier $x$, it is simply looked up in the environment $\Delta$

\subsubsection{Vector}

$$(\Delta, (e_1, e_2, ..., e_n)) \Rightarrow (v_1, v_2, ..., v_n)$$

\noindent\makebox[\linewidth]{\rule{2.1in}{0.4pt}}
$$(\Delta, e_1) \Rightarrow v_1$$
$$(\Delta, e_2) \Rightarrow v_2$$
$$\dots$$
$$(\Delta, e_n) \Rightarrow v_n$$


To evaluate a vector, evaluate each sub expression, then construct a new vector with the values

\subsubsection{Cons}

$$(\Delta, e_1 :: e_2) \Rightarrow v_1 :: v_2$$
\noindent\makebox[\linewidth]{\rule{1.4in}{0.4pt}}
$$(\Delta, e_1) \Rightarrow v_1$$
$$(\Delta, e_2) \Rightarrow v_2$$

To evaluate a cons expression, evaluate the two operands, then return the first argument prepended to the second

\subsection{Switch Statement Semantics}

A switch statement uses an expression, call it $e_0$ and a list of branches. Each branch consists of a pattern and a body.

First, $e_0$ is evaluted to a value $v_0$ using the current environment $\Delta$

Starting from the first branch, $v_0$ is compared to its pattern. If it matches, certain bindings are produced, which are used to evaluate its body. That value is then returned.

This process of comparing $v_0$ to the pattern of a branch continues until a match is made.



$$(\Delta, \text{switch e} => | p_1 \rightarrow e_1 ... | p_n \rightarrow e_n \text{ end}) \implies v'$$
\noindent\makebox[\linewidth]{\rule{3in}{0.4pt}}
$$(\Delta, e) \implies v$$
$$v \notin p_i \text{ for } i < m$$
$$v \in p_m \rightarrow \Delta_m \text{ where } 1 \leq m \leq n$$
$$(\Delta \circ \Delta_m, e_j) \implies v'$$


Let's go through those statements one by one

\begin{enumerate}

\item $(\Delta, e) \implies v$ shows that $e$ evalutes to $v$ under environment $\Delta$

\item $v \notin p_i \text{ for } i < m$ shows that $v$ doesn't match the first $m - 1$ patterns

\item $v \in p_m \rightarrow \Delta_m \text{ where } 1 \leq m \leq n$ shows that $v$ matches the $m^ \text{th}$ pattern and produces bindings $\Delta_m$

\item $(\Delta \circ \Delta_m, e_m) \implies v'$ shows that the body of the $m ^ \text{th}$ branch evaluates to a value $v'$ under the external environment $\Delta$ composed with the new bindings $\Delta_m$. $v'$ is what the entire switch expression evaluates to.

\end{enumerate}



\subsection{Ternary Expression}

There are two rules regarding the dynamic semantics of ternary expressions. There is one for when the predicate is true and one for when the predicate is false.


$$(\Delta, \text{if } e_1 \text{ then } e_2 \text{ else } e_3) \implies v$$
\noindent\makebox[\linewidth]{\rule{2.2in}{0.4pt}}
$$(\Delta, e_1) \implies \text{true}$$
$$(\Delta, e_2) \implies v$$
\noindent\makebox[\linewidth]{\rule{3in}{0.4pt}}
$$(\Delta, \text{if } e_1 \text{ then } e_2 \text{ else } e_3) \implies v$$
\noindent\makebox[\linewidth]{\rule{2.2in}{0.4pt}}
$$(\Delta, e_1) \implies \text{false}$$
$$(\Delta, e_3) \implies v$$

\subsection{Function}

A function in LambdaScript evaluates to a function closure, which consists of three parts: the environment, the pattern, and the body.

$$(\Delta, \text{fn } p \rightarrow e) \implies (\Delta, p, e)$$

\subsection{Function Application}

$$(\Delta, e_1 \text{ } e_2) \implies v$$
\noindent\makebox[\linewidth]{\rule{1.2in}{0.4pt}}

$$(\Delta, e_1) \implies (\Delta_c, p_c, e_c)$$
$$(\Delta, e_2) \implies v_2$$
$$v_2 \in p_c \implies \Delta_n$$
$$(\Delta_c \circ \Delta_n, e_c) \implies v$$

Let's go through these statements one by one

\begin{enumerate}
\item $(\Delta, e_1) \implies (\Delta_c, p_c, e_c)$ states that $e_1$ evaluates to a function closure. This is crucial because if $e_1$ is not a function closure, it cannot be applied.
\item $(\Delta, e_2) \implies v_n$ states that $e_2$, the argument, evaluates to a value $v_2$
\item $v_2 \in p_c \implies \Delta_2$ states that $v_2$, the value of the argument, matches the pattern of the function closure $p_c$ and produces bindings $\Delta_n$
\item $(\Delta_c \circ \Delta_n, e_c) \implies v$ states that $e_2$, the body of the function closure, evaluates to a value $v$ under the environment of the function closure, $\Delta_c$ composed with the new bindings $\Delta_n$, which result from matching the value of the argument $v$ against the pattern $p_c$. The entire expression evalutes to $v$.

\end{enumerate}
\section{Static Semantics}

\end{document}