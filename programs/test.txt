let rec fold f acc lst <-
  switch lst =>
  | [] -> acc
  | h :: t -> fold f (f acc h) t
  end
  in fold

let rec fold f lst acc <-
  switch lst =>
  | [] -> acc
  | h :: t -> f h (fold f t acc)
  end 
  in fold

let rec map f lst <-
  switch lst =>
  | [] -> []
  | h :: t -> f h :: map f t
  end

let rec iter f lst <-
  switch lst =>
  | [] -> ()
  | h :: t -> 
    let () <- f h in
    iter f t
  end

let rec (++) arr1 arr2 <-
  switch arr1 =>
  | [] -> arr2
  | h :: t -> h :: (t ++ arr2)
  end

let rec flatten lst <-
  switch lst =>
  | [] -> []
  | h :: t -> h ++ flatten t
  end

let print_int x <-
  println (int_to_str x)

let print_int_list <- iter print_int

let return x <- [x]

let (>>=) lst f <-
  flatten (map f lst)

let (-->) x f <- f x

let (<->) f g x <- f (g x)


let id <- ((+) 1) <-> (\x -> x - 1)

let squares a b <- [x * x | x <- [a ... b]]

let arr <- [1 ... 5]

let arr1 <- fold_left (-) 0 arr
let arr2 <- fold_right (-) arr 0

let () <- print_int arr1
let () <- print_int arr2


