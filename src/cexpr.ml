(** c_pat represents a pattern *)
type c_pat =
  | CIntPat of int
  | CBoolPat of bool
  | CNilPat
  | CConsPat of c_pat * c_pat
  | CWildcardPat
  | CVectorPat of c_pat list
  | CStringPat of string
  | CIdPat of string
  | CUnitPat
  | CConstructorPat of string (* string is the name of the constructor *)
  | CAppPat of c_pat * c_pat (* constructor application *)

(** c_bop represents a built-in binary operator *)
type c_bop =
  | CPlus
  | CMinus
  | CMul
  | CDiv
  | CMod
  | CEQ
  | CNE
  | CLT
  | CGT
  | CLE
  | CGE
  | CAnd
  | COr
  | CCons

(** c_defn represents a top-level definition. It can be one of the following:
    - CDefn: a non-recursive definition
    - CDefnRec: a recursive definition
    - CTypeDefn: a definition of a type alias
    - CUnionDefn: a definition of a union type *)
and c_defn =
  | CDefn of c_pat * c_type option * c_expr
  | CDefnRec of c_pat * c_type option * c_expr
  | CTypeDefn of string * c_type * string list
  | CUnionDefn of string * c_constructor list * string list

(** c_constructor represents a constructor of a union type There are two kinds
    of constructors:
    - CNullaryConstructor: a nullary constructor (no arguments)
    - CUnaryConstructor: a unary constructor (one argument) *)
and c_constructor =
  | CNullaryConstructor of string
  | CUnaryConstructor of
      string * c_type (* represents a variant type constructor *)

and c_switch_branch = c_pat * c_expr
(** c_switch_branch represents a branch of a switch expression It is a pair of a
    pattern and an expression *)

(** c_expr represents an expression *)
and c_expr =
  | EFunction of c_pat * c_type option * c_expr
  | EBindRec of c_pat * c_type option * c_expr * c_expr
  | ETernary of c_expr * c_expr * c_expr
  | ESwitch of c_expr * c_switch_branch list
  | EBool of bool
  | EString of string
  | EUnit
  | EInt of int
  | EFloat of float
  | EId of string
  | EApp of c_expr * c_expr
  | EBop of c_bop * c_expr * c_expr
  | EVector of c_expr list
  | ENil
  | EListEnumeration of c_expr * c_expr
  | EListComprehension of c_expr * (c_pat * c_expr) list
  | EConstructor of string

(** c_type represents a type
    - TypeName is a type alias for some type
    - TypeVarWritten is a type variable that is written in the source code
    - TypeVar is a type variable that is generated by the type checker. It has
      one "identity", in the sense that it is not universally quantified.
    - UniversalType is a universally quantified type variable. It has many
      "identifities", in the sense that it can be instantiated to yield
      infinately many type variables.
    - PolymorphicType (t1, t2) represents a polymorphic type. t1 is the argument
      and t2 is the body. In the future, there will be type patterns for usage
      here.
    - AppType (t1, t2) represents a type application. t1 is the function and t2
      is the argument.
    - Uniontype is a union type. It contains the list of constructors. *)
and c_type =
  | IntType
  | FloatType
  | BoolType
  | StringType
  | UnitType
  | TypeName of string
  | TypeVarWritten of string
  | FunctionType of c_type * c_type
  | VectorType of c_type list
  | TypeVar of int
  | CListType of c_type
  | AppType of c_type * c_type
  | UniversalType of int
  | PolymorphicType of c_type * c_type
    (* the left c_type is the argument and the right c_type is the body *)
  | UnionType of c_constructor list

(** c_kind represents a kind (the type of a type)
    - Star is the kind of any type
    - Arrow (k1, k2) is the kind of a type constructor that takes a type of kind
      k1 as an argument and returns a type of kind k2.
    - KindVar (i) is a kind variable with identity i *)
and c_kind =
  | Star
  | Arrow of c_kind * c_kind
  | KindVar of int

(** value represents a value, which is an expression that cannot be evaluated
    any further *)
and value =
  | IntegerValue of int
  | FloatValue of float
  | StringValue of string
  | BooleanValue of bool
  | UnitValue
  | FunctionClosure of env * c_pat * c_type option * c_expr
  | RecursiveFunctionClosure of env ref * c_pat * c_type option * c_expr
  | VectorValue of value list
  | ListValue of value list
  | BuiltInFunction of builtin_function
  | ConstructorValue of string * value option
(* string is the name of the constructor if it is applied, the value is Some
   value, where value is the value contained in the constructor *)

(** builtin_function represents a function that has predefined behavior by the
    interpreter *)
and builtin_function =
  | Println
  | Print
  | IntToString
  | StringToInt
  | IntToFloat
  | FloatToInt
  | Map
  | Filter
  | ReduceLeft
  | ReduceRight

and env = (string * value) list
(** env represents a dynamic environment, which is a mapping from identifiers to
    values *)

type static_env = (string * c_type) list
(** static_env represents a static environment, which is a mapping from
    identifiers to types *)

type c_program = c_defn list
(** c_program represents a program. It is just a list of definitions *)

(** This is syntactic sugar for creating a function type *)
let ( => ) (t1 : c_type) (t2 : c_type) : c_type = FunctionType (t1, t2)

let counter : int ref = ref 0

(** Generates a fresh type variable *)
let fresh_type_var : unit -> c_type =
 fun () ->
  counter := !counter + 1;
  TypeVar !counter

let counter_2 : int ref = ref 0

(** Generates a fresh universal type variable *)
let fresh_universal_type : unit -> c_type =
 fun () ->
  counter_2 := !counter_2 + 1;
  UniversalType !counter_2

let counter_3 : int ref = ref 0

(** Generates a fresh kind variable *)
let fresh_kind_var : unit -> c_kind =
 fun () ->
  counter_3 := !counter_3 + 1;
  KindVar !counter_3

(** Resets all type variable counters used for generating fresh variables *)
let reset_type_counters : unit -> unit =
 fun () ->
  counter := 0;
  counter_2 := 0;
  counter_3 := 0
